# 01 - 产品设计

## 1. 产品理念

### 1.1 核心问题

当前 Semibot 是一个纯云端 Agent 平台：

```
用户 → Web → API → Runtime（云端）→ LLM
```

这带来三个根本性限制：

1. **无法操作用户本地环境** — Agent 不能读写用户的文件、运行用户的代码、操作用户的浏览器
2. **并发 session 文件冲突** — 多个 session 共享同一个 Runtime 进程，文件操作互相干扰
3. **凭证安全困境** — 用户的密码、Cookie、API Key 必须上传到云端才能使用

OpenClaw 通过"全部跑在本地"解决了这些问题，但失去了多租户、团队协作、进化技能等企业级能力。

### 1.2 设计目标

**将 Semibot 改造为"云端大脑 + 本地双手"架构：**

- 云端（控制平面）负责思考：Agent 定义、技能管理、长期记忆、进化治理、审计计费
- 用户虚拟机（执行平面）负责动手：代码执行、文件操作、浏览器控制、LLM 调用
- 每个用户分配一个虚拟机，等同于一台"个人电脑"，多个 session 作为独立进程共享同一文件系统

**一句话定位：** 企业级 Agent 编排平台，兼具云端管控能力和本地执行安全性。

### 1.3 与 OpenClaw 的差异化

| 维度 | OpenClaw | Semibot（重构后） |
|------|----------|------------------|
| 定位 | 个人开发者的本地 Agent | 团队/企业的 Agent 编排平台 |
| 执行环境 | 只能本地 | 云端虚拟机 / 本地机器 / 混合 |
| 运行时 | 单一 Node.js runtime | 双运行时（Semibot Python/LangGraph + OpenClaw Node.js），每 session 可切换 |
| 并发隔离 | 无（单用户单进程） | 用户级虚拟机隔离，多 session 进程级复用 |
| 技能管理 | SKILL.md 文件 + ClawHub | 双层模型 + 版本锁定 + 安装审计 |
| 进化技能 | 无 | LLM 自动生成 → 审核 → 跨 session 复用 |
| 团队协作 | 无 | 多租户 + 角色权限 + 共享 Agent |
| 长期记忆 | 无 | pgvector 向量检索 + 跨 session 积累 |
| 离线能力 | 天然支持 | 执行平面可离线运行（退化模式） |

**Semibot 不可替代的四个优势：**

1. **用户级隔离** — 每个用户一个虚拟机（= 个人电脑），不同用户绝对隔离；同一用户的多个 session 共享文件系统，通过独立进程运行
2. **双运行时** — 同时支持 Semibot 自研 runtime 和 OpenClaw 开源 runtime，用户按需选择，控制平面和前端无感知
3. **进化技能** — 从成功执行中自动提炼技能，跨 session/用户复用
4. **团队协作** — 多人共享 Agent、技能、记忆，统一管控

## 2. 用户场景

### 2.1 场景一：企业开发团队

```
团队管理员：
  → 在控制平面创建 Agent（代码审查助手）
  → 绑定技能（Git 操作、代码分析、Jira 集成）
  → 配置 MCP Server（GitHub、Jira）
  → 设置团队权限

开发者 A：
  → 打开 Web，选择"代码审查助手"
  → 控制平面为开发者 A 分配一个云端虚拟机（= 个人电脑）
  → Agent 在虚拟机里 clone 代码、运行测试、生成报告
  → 开发者 A 同时开多个 session，共享同一个虚拟机的文件系统
  → 报告通过 SSE 流式推送到浏览器

开发者 B（同时）：
  → 也在用同一个 Agent
  → 控制平面为开发者 B 分配另一个虚拟机
  → 两人的虚拟机完全隔离，互不干扰
```

### 2.2 场景二：个人开发者（本地模式）

```
开发者：
  → 在本地机器安装 Semibot 执行平面（轻量 Runtime）
  → 执行平面通过 WebSocket 连接云端控制平面
  → Agent 直接操作本地文件、运行本地代码
  → 密码和 Cookie 留在本地，不上传云端
  → 断网时退化为纯本地模式（没有长期记忆和技能市场）
```

### 2.3 场景三：混合模式

```
数据分析师：
  → Agent 需要操作本地 Excel 文件（本地执行平面处理）
  → 同时需要调用云端 API 生成报告（通过控制平面的 MCP 连接池）
  → 生成的报告存入长期记忆（控制平面）
  → 下次类似任务，Agent 从长期记忆中检索历史报告作为参考
```

### 2.4 场景四：OpenClaw 运行时

```
开发者（已有 OpenClaw 使用经验）：
  → 在控制平面创建 Agent，选择 runtime_type = openclaw
  → 控制平面为用户分配虚拟机，VM 内预装 Semibot + OpenClaw 双运行时
  → 用户发送消息，SessionManager 启动 OpenClaw Bridge 进程
  → Bridge 驱动 OpenClaw 原生 Brain/Skills/Memory 运行
  → Bridge 将 OpenClaw 事件翻译为 Semibot SSE 格式，前端无感知
  → 用户可在同一 VM 内同时运行 Semibot session 和 OpenClaw session
  → Skill 缓存共享（两者都使用 SKILL.md 格式）
  → 长期记忆共享（都通过 WS 请求控制平面）
```

## 3. 产品需求

### 3.1 P0 — 必须实现

| 需求 | 描述 |
|------|------|
| 用户级虚拟机隔离 | 每个用户分配一个虚拟机（= 个人电脑），不同用户之间完全隔离；同一用户的多个 session 作为独立进程共享文件系统 |
| 统一 WebSocket 通信 | 每个虚拟机一条 WebSocket 反向连接控制平面，多 session 通过 session_id 多路复用，不区分部署模式 |
| LLM 直连 | 执行平面直连 LLM Provider，API Key 由控制平面注入，用完擦除 |
| SSE 流式输出 | 前端通过控制平面接收 SSE 流，支持断线重连和缓冲区重放 |
| 技能懒加载 | 启动时只传索引，执行时按需从控制平面拉取 SKILL.md |
| 短期记忆本地化 | 短期记忆存为 MD 文件在执行平面本地，不依赖 Redis |
| 长期记忆云端化 | 长期记忆保持在控制平面的 pgvector，通过 WebSocket 检索 |
| Checkpoint 恢复 | LangGraph 状态持久化到本地文件，进程崩溃后可恢复 |

### 3.2 P1 — 应该实现

| 需求 | 描述 |
|------|------|
| 云端虚拟机模式 | 控制平面自动分配 Firecracker 虚拟机作为执行平面 |
| 本地执行平面 | 用户可在本地安装轻量 Runtime，连接云端控制平面 |
| 心跳检测 | 控制平面检测执行平面存活，虚拟机崩溃时自动恢复 |
| 状态快照同步 | 执行平面定期将关键状态同步到控制平面，用于灾难恢复 |
| OAuth 集成 | 控制平面管理 OAuth token，按需注入执行平面 |
| 远程 MCP 连接池 | 平台提供的远程 MCP Server 在控制平面共享连接池 |
| 双运行时支持 | 执行平面同时支持 Semibot（Python/LangGraph）和 OpenClaw（Node.js）两种 runtime，每个 session 可独立选择，通过 RuntimeAdapter 抽象层统一管理 |

### 3.3 P2 — 可以实现

| 需求 | 描述 |
|------|------|
| 本地浏览器代理 | 需要操作浏览器时，指令转发到用户本地浏览器执行 |
| 凭证保险箱 | 加密存储用户凭证，使用时需用户授权，用完擦除 |
| 虚拟机空闲冻结 | 空闲 30s 后冻结虚拟机释放内存，用户发消息时从快照恢复 |
| 跨区域调度 | 根据用户地理位置分配最近的虚拟机 |

## 4. 非功能需求

| 维度 | 指标 |
|------|------|
| SSE 延迟 | 云端模式 < 50ms，本地模式 < 200ms |
| 虚拟机启动 | < 3s（Firecracker）/ < 10s（Docker） |
| 进程崩溃恢复 | < 5s（从 checkpoint 恢复） |
| 虚拟机崩溃恢复 | < 15s（新虚拟机 + 挂载旧磁盘） |
| WebSocket 重连 | < 5s（指数退避，最大 30s） |
| 并发用户 | 单台物理机 100+ 用户虚拟机（Firecracker）/ 20+（Docker） |
| 内存占用 | 单用户虚拟机 < 1GB（含 Chrome 时 < 2GB） |
