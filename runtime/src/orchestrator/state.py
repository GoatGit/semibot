"""Agent state type definitions for LangGraph orchestration."""

from typing import Annotated, Any, Literal, TYPE_CHECKING
from typing_extensions import TypedDict
from pydantic import BaseModel, Field
from operator import add

if TYPE_CHECKING:
    from src.orchestrator.context import RuntimeSessionContext


class PlanStep(BaseModel):
    """A single step in the execution plan."""

    id: str = Field(..., description="Unique step identifier")
    title: str = Field(..., description="Step title/description")
    tool: str | None = Field(default=None, description="Tool to execute")
    params: dict[str, Any] = Field(default_factory=dict, description="Tool parameters")
    parallel: bool = Field(default=False, description="Whether this step can run in parallel")
    status: Literal["pending", "running", "completed", "failed"] = Field(default="pending")
    result: Any = Field(default=None, description="Step execution result")
    error: str | None = Field(default=None, description="Error message if failed")


class ExecutionPlan(BaseModel):
    """Execution plan generated by the planner."""

    goal: str = Field(..., description="The overall goal to achieve")
    steps: list[PlanStep] = Field(default_factory=list, description="List of steps to execute")
    current_step_index: int = Field(default=0, description="Index of current step")
    requires_delegation: bool = Field(
        default=False, description="Whether this plan requires SubAgent delegation"
    )
    delegate_to: str | None = Field(
        default=None, description="SubAgent ID to delegate to, if applicable"
    )


class ToolCallResult(BaseModel):
    """Result of a tool call execution."""

    tool_name: str
    params: dict[str, Any]
    result: Any = None
    error: str | None = None
    duration_ms: int = 0
    success: bool = True
    metadata: dict[str, Any] = Field(default_factory=dict)


class ReflectionResult(BaseModel):
    """Result of the reflection phase."""

    summary: str = Field(..., description="Summary of what was accomplished")
    lessons_learned: list[str] = Field(
        default_factory=list, description="Key lessons from this execution"
    )
    worth_remembering: bool = Field(
        default=False, description="Whether this should be stored in long-term memory"
    )
    importance: float = Field(
        default=0.5, ge=0.0, le=1.0, description="Importance score for memory storage"
    )


class Message(TypedDict):
    """A message in the conversation."""

    role: Literal["user", "assistant", "system", "tool"]
    content: str
    name: str | None
    tool_call_id: str | None


class AgentState(TypedDict):
    """
    Agent execution state for LangGraph.

    This is the central state object that flows through all nodes in the state graph.
    Each node can read and update this state.

    Attributes:
        session_id: Unique session identifier for tracking
        agent_id: The agent being executed
        org_id: Organization ID for multi-tenancy
        context: Runtime session context with agent config and capabilities
        messages: Conversation history (accumulates via reducer)
        current_step: Current state in the state machine
        plan: The execution plan generated by PLAN node
        pending_actions: Actions waiting to be executed
        tool_results: Results from tool executions (accumulates via reducer)
        memory_context: Retrieved memory context
        reflection: Reflection summary after task completion
        iteration: Current iteration count (for loop protection)
        error: Any error that occurred
        metadata: Additional metadata for tracking
    """

    # Identifiers
    session_id: str
    agent_id: str
    org_id: str

    # Runtime context (NEW)
    context: "RuntimeSessionContext"

    # Conversation state - uses add reducer to accumulate messages
    messages: Annotated[list[Message], add]

    # State machine control
    current_step: Literal["start", "plan", "act", "delegate", "observe", "reflect", "respond"]

    # Planning state
    plan: ExecutionPlan | None
    pending_actions: list[PlanStep]

    # Execution state - uses add reducer to accumulate results
    tool_results: Annotated[list[ToolCallResult], add]

    # Memory state
    memory_context: str

    # Reflection state
    reflection: ReflectionResult | None

    # Control state
    iteration: int
    error: str | None

    # Metadata
    metadata: dict[str, Any]


def create_initial_state(
    session_id: str,
    agent_id: str,
    org_id: str,
    user_message: str,
    context: "RuntimeSessionContext",
    metadata: dict[str, Any] | None = None,
) -> AgentState:
    """
    Create an initial agent state for a new execution.

    Args:
        session_id: Unique session identifier
        agent_id: The agent to execute
        org_id: Organization ID
        user_message: The user's input message
        context: Runtime session context with agent config and capabilities
        metadata: Optional additional metadata

    Returns:
        A properly initialized AgentState
    """
    return AgentState(
        session_id=session_id,
        agent_id=agent_id,
        org_id=org_id,
        context=context,
        messages=[Message(role="user", content=user_message, name=None, tool_call_id=None)],
        current_step="start",
        plan=None,
        pending_actions=[],
        tool_results=[],
        memory_context="",
        reflection=None,
        iteration=0,
        error=None,
        metadata=metadata or {},
    )
